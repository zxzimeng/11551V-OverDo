{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nLeftMotor = Motor(Ports.PORT12, False)\nRightMotor = Motor(Ports.PORT11, True)\nTouchLedR = Touchled(Ports.PORT10)\nTouchLedL = Touchled(Ports.PORT9)\n#endregion VEXcode Generated Robot Configuration\n\nimport math\n\n#defining constants for use in calculations\nLENGTH = 15*2.54\nPI = math.pi\nWHEELSIZE = 20\n\n#defines maxmium amount of deviation from target rotation (in degrees)\nMAX_ALLOWED_DEVIATION = 0.5\n\n#defines angle impercision of gryo\nCOOLDOWN_TURN = 0\n\n#defines cooldown % of turn to stop at to account for momentum\nSLOWDOWN_TURN = 0\n\n#defines how much speed to increase porportional to the deviation (correction_speed = ln(deviation)/ln(vcorrection_delta) | lower is more correctoin\nVCORRECTION_DELTA = 1.25\n\n#toggles verbose output for debugging\nVERBOSE = True\n\n\n# def optimization_straight(tries, start, increment):\n#     global VCORRECTION_DELTA\n#     VCORRECTION_DELTA = start\n\n#     print(\"\\ntries\", tries, \"start\", start, \"increment\", increment)\n\n#     tries_data = []\n#     for i in range(tries):\n#         tries_data.append(drivestraight(60, 90)+[VCORRECTION_DELTA])\n#         VCORRECTION_DELTA += increment \n#         wait(0.8, SECONDS)\n    \n#     tries_data.sort()\n#     print(tries_data)\n\ndef log_velocity_deviation(extra, xvelocity, deviation):\n    if VERBOSE:\n        print(extra, \"velocity_change\", xvelocity, \"deviation\", deviation)\n\n#turn signals for left and right and straight\ndef reset_color():\n    TouchLedR.set_brightness(0)\n    TouchLedL.set_brightness(0)\n\ndef turn_right_color():\n    TouchLedL.set_brightness(0)\n    TouchLedR.set_brightness(100)\n    TouchLedR.set_color(Color.RED_ORANGE)\n\ndef turn_left_color():\n    TouchLedR.set_brightness(0)\n    TouchLedL.set_brightness(100)\n    TouchLedL.set_color(Color.RED_ORANGE)\n\ndef drive_straight_color():\n    TouchLedR.set_brightness(100)\n    TouchLedL.set_brightness(100)\n    TouchLedR.set_color(Color.VIOLET)\n    TouchLedL.set_color(Color.VIOLET)\n\ndef drivestraight(distance, velocity, offset=0):\n    # insight values\n    imax_deviation = -9999\n    imin_deviation = 9999    \n    itotal_deviation = 0\n    iytotal_displacement = 0\n    idatapoints = 0\n    istarttime = 0\n\n    # gets current brain rotation (not heading as it resets to 0 on a full turn)\n    target_rotation = brain_inertial.rotation()-offset\n\n    # calcuates min and max accepted rotation with deviation\n    min_rotation = target_rotation - MAX_ALLOWED_DEVIATION\n    max_rotation = target_rotation + MAX_ALLOWED_DEVIATION\n\n    # calculates wheel rotation needed to reach distance; 200mm wheels, 4:3 gear ratio\n    total_wheel_rotation = distance/20*360*0.75\n\n    # gets wheel position so that it can calculate final rotations\n    left_motor_start_pos = LeftMotor.position(DEGREES)\n    right_motor_start_pos = RightMotor.position(DEGREES)\n\n    while abs(LeftMotor.position(DEGREES)-left_motor_start_pos) < total_wheel_rotation and abs(RightMotor.position(DEGREES)-right_motor_start_pos) < total_wheel_rotation:\n        current_rotation = brain_inertial.rotation()\n\n        actual_deviation = current_rotation-target_rotation\n        percieved_deviation = abs(actual_deviation)\n        \n        #insights\n        imax_deviation = max(actual_deviation, imax_deviation)\n        imin_deviation = min(actual_deviation, imin_deviation)\n        itotal_deviation += percieved_deviation\n        idatapoints += 1\n\n        #calculates velocity change\n        velocity_change = math.log(percieved_deviation+0.1)/math.log(VCORRECTION_DELTA)\n        \n        #handles veering right | tries to go left by speeding up right motor\n        if current_rotation > max_rotation:\n            log_velocity_deviation(\"LEFTBYRIGHT\", velocity_change, percieved_deviation)\n            LeftMotor.set_velocity(velocity-velocity_change)\n            RightMotor.set_velocity(velocity+velocity_change)\n            turn_left_color()\n\n        #handles veering left | tries to go right by speeding up left motor\n        elif current_rotation < min_rotation:\n            log_velocity_deviation(\"RIGHTBYLEFT\", velocity_change, percieved_deviation)\n            LeftMotor.set_velocity(velocity+velocity_change)\n            RightMotor.set_velocity(velocity-velocity_change)\n            turn_right_color()\n\n        #handles going straight\n        elif current_rotation <= max_rotation and current_rotation >= min_rotation:\n            log_velocity_deviation(\"NOTHANDLED\", velocity_change, percieved_deviation)\n            LeftMotor.set_velocity(velocity)\n            RightMotor.set_velocity(velocity)\n            drive_straight_color()\n\n        # actually spins motors\n        LeftMotor.spin(FORWARD)\n        RightMotor.spin(FORWARD)\n\n        wait(10)\n    \n    LeftMotor.stop()\n    RightMotor.stop()\n\n    print(\"max rotation\", imax_deviation, \"\\nmin rotation\", imin_deviation, \"\\naverage deviation\", itotal_deviation/idatapoints)\n    return [imax_deviation+abs(imin_deviation), itotal_deviation/idatapoints, imax_deviation, imin_deviation]\n\ndef turnLeftWithRight(threshold):\n    # Initialize the starting angle\n    starting_angle = brain_inertial.rotation()\n\n    # Turn the robot on the left wheel\n    while True:\n        # Get the current angle\n        current_angle = brain_inertial.rotation()\n        \n        # Calculate the angle difference\n        angle_diff = abs(current_angle - starting_angle)\n        \n        # Check if the angle difference has reached the threshold\n        if angle_diff >= threshold:\n            # Stop the motors\n            LeftMotor.stop()\n            RightMotor.stop()\n            break\n        \n        # Set the motor speeds\n        LeftMotor.set_velocity(-25)\n        RightMotor.set_velocity(50)\n        RightMotor.spin(FORWARD)\n        LeftMotor.spin(FORWARD)\n\n        # Sleep for a short period\n        wait(10)\n\ndef turnRightWithLeft(threshold):\n\n    # Initialize the starting angle\n    starting_angle = brain_inertial.rotation()\n\n    # Turn the robot on the left wheel\n    while True:\n        # Get the current angle\n        current_angle = brain_inertial.rotation()\n        \n        # Calculate the angle difference\n        angle_diff = abs(current_angle - starting_angle)\n        \n        # Check if the angle difference has reached the threshold\n        if angle_diff >= threshold:\n            # Stop the motors\n            LeftMotor.stop()\n            RightMotor.stop()\n            break\n        \n        # Set the motor speeds\n        LeftMotor.set_velocity(50)\n        RightMotor.set_velocity(-25)\n        RightMotor.spin(FORWARD)\n        LeftMotor.spin(FORWARD)\n        \n        # Sleep for a short period\n        wait(10)\n\ndef yellow():\n    drivestraight(94, 80)\n    turnLeftWithRight(90)\n\ndef when_started1():\n    drivestraight(57, 80)\n    turnRightWithLeft(20)\n    pass\n\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[12],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[11],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[10],"name":"TouchLedR","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[9],"name":"TouchLedL","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":1,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","target":"Physical"}