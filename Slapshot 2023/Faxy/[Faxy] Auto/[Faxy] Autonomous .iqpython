{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nLeftMotor = Motor(Ports.PORT12, False)\nRightMotor = Motor(Ports.PORT11, True)\nTouchLedR = Touchled(Ports.PORT10)\nTouchLedL = Touchled(Ports.PORT9)\n#endregion VEXcode Generated Robot Configuration\n\nimport math\n\n#defining constants for use in calculations\nLENGTH = 15*2.54\nPI = math.pi\nWHEELSIZE = 6.985\n\n#defines maxmium amount of deviation from target rotation (in degrees)\nMAX_ALLOWED_DEVIATION = 0.5\n\n#defines how much speed to increase porportional to the deviation (correction_speed = ln(deviation)/ln(vcorrection_delta) | lower is more correctoin\nVCORRECTION_DELTA = 1.15\n\n#turn signals for left and right and straight\ndef reset_color():\n    TouchLedR.set_brightness(0)\n    TouchLedL.set_brightness(0)\n\ndef turn_right_color():\n    TouchLedL.set_brightness(0)\n    TouchLedR.set_brightness(100)\n    TouchLedR.set_color(Color.RED_ORANGE)\n\ndef turn_left_color():\n    TouchLedR.set_brightness(0)\n    TouchLedL.set_brightness(100)\n    TouchLedL.set_color(Color.RED_ORANGE)\n\ndef drive_straight_color():\n    TouchLedR.set_brightness(100)\n    TouchLedL.set_brightness(100)\n    TouchLedR.set_color(Color.VIOLET)\n    TouchLedL.set_color(Color.VIOLET)\n\ndef drivestraight(distance, velocity):\n    # insight values\n    imax_deviation = -9999\n    imin_deviation = 9999    \n    itotal_deviation = 0\n    iytotal_displacement = 0\n    idatapoints = 0\n    istarttime = 0\n\n    # gets current brain rotation (not heading as it resets to 0 on a full turn)\n    target_rotation = brain_inertial.rotation()\n\n    # calcuates min and max accepted rotation with deviation\n    min_rotation = target_rotation - MAX_ALLOWED_DEVIATION\n    max_rotation = target_rotation + MAX_ALLOWED_DEVIATION\n\n    # calculates wheel rotation needed to reach distance; 200mm wheels, 4:3 gear ratio\n    total_wheel_rotation = distance/20*360*0.75\n\n    # gets wheel position so that it can calculate final rotations\n    left_motor_start_pos = LeftMotor.position(DEGREES)\n    right_motor_start_pos = RightMotor.position(DEGREES)\n\n    while abs(LeftMotor.position(DEGREES)-left_motor_start_pos) < total_wheel_rotation and abs(RightMotor.position(DEGREES)-right_motor_start_pos) < total_wheel_rotation:\n        current_rotation = brain_inertial.rotation()\n\n        actual_deviation = current_rotation-target_rotation\n        percieved_deviation = abs(actual_deviation)\n        \n        #insights\n        imax_deviation = max(actual_deviation, imax_deviation)\n        imin_deviation = min(actual_deviation, imin_deviation)\n        itotal_deviation += percieved_deviation\n        idatapoints += 1\n\n        #calculates velocity change\n        velocity_change = math.log(percieved_deviation+0.1)/math.log(VCORRECTION_DELTA)\n        \n        #handles veering right | tries to go left by speeding up right motor\n        if current_rotation > max_rotation:\n            print(\"velocity_change\", velocity_change, \"deviation\", actual_deviation)\n            LeftMotor.set_velocity(velocity-velocity_change)\n            RightMotor.set_velocity(velocity+velocity_change)\n            turn_left_color()\n\n        #handles veering left | tries to go right by speeding up left motor\n        elif current_rotation < min_rotation:\n            print(\"velocity_change\", velocity_change, \"deviation\", actual_deviation)\n            LeftMotor.set_velocity(velocity+velocity_change)\n            RightMotor.set_velocity(velocity-velocity_change)\n            turn_right_color()\n\n        #handles going straight\n        elif current_rotation <= max_rotation and current_rotation >= min_rotation:\n            print(\"NOTHANDLED\", \"velocity_change\", velocity_change, \"deviation\", actual_deviation)\n            LeftMotor.set_velocity(velocity)\n            RightMotor.set_velocity(velocity)\n            drive_straight_color()\n\n        # actually spins motors\n        LeftMotor.spin(FORWARD)\n        RightMotor.spin(FORWARD)\n    \n    LeftMotor.stop()\n    RightMotor.stop()\n\n    print(\"max rotation\", imax_deviation, \"\\nmin rotation\", imin_deviation, \"\\naverage deviation\", itotal_deviation/idatapoints)\n\ndef turnAxis(theta, direction):\n    turn_rotations = theta/360 * 2*PI*LENGTH / WHEELSIZE\n\n    if theta < 0: #indicates a left turn - we use right motor for this\n        RightMotor.spin_for(direction, turn_rotations, TURNS)\n        return  \n\n    LeftMotor.spin_for(direction, turn_rotations, TURNS)\n\ndef yellow():\n    drivestraight(106.68, 90)\n    turnAxis(-90, FORWARD)\n    drivestraight(5, 30)\n    turnAxis(-30, FORWARD)\n    turnAxis(30, FORWARD)\n\ndef when_started1():\n    drivestraight(40, 70)\n    pass\n\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[12],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[11],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[10],"name":"TouchLedR","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[9],"name":"TouchLedL","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":1,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","target":"Physical"}